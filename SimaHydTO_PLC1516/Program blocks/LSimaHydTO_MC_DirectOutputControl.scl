FUNCTION_BLOCK "LSimaHydTO_MC_DirectOutputControl"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : APC_ERLF
FAMILY : LSimaHydTO
VERSION : 1.0
   VAR_INPUT 
      JogForward : Bool;
      JogBackward : Bool;
      CommandValueForward : LReal := 5.0;
      CommandValueBackward : LReal := 5.0;
      CommandValueRamp : LReal := 100.0;
      SafetyDistance : LReal := 50.0;
   END_VAR

   VAR_OUTPUT 
      CommandAborted { ExternalWritable := 'False'} : Bool;
      Busy { ExternalWritable := 'False'} : Bool;
      Error { ExternalWritable := 'False'} : Bool;
      ErrorID { ExternalWritable := 'False'} : Word;
      RampingDown { ExternalWritable := 'False'} : Bool;
      MinSafetyPositionOverrun { ExternalWritable := 'False'} : Bool;
      MaxSafetyPositionOverrun { ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_IN_OUT 
      Axis : "LSimaHydTO_typeAxisData";
   END_VAR

   VAR 
      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statJigFwdOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statJogBkwdOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR CONSTANT 
      FB_STATE_IDLE : DInt;
      FB_STATE_JOG : DInt := 10;
      FB_STATE_STOPPING : DInt := 20;
      FB_STATE_COMMAND_ABORTED : DInt := 30;
      FB_STATE_ERROR : DInt := -100;
      NO_ERROR_REACTION : DInt := 0;
      NO_ALARM : Word := 0;
      ALARM_AXIS_ERROR_OCCURED : Word := 16#8001;
      ALARM_WRONG_VALUE_VELOCITY : Word := 16#8003;
      ALARM_WRONG_VALUE_ACCEL : Word := 16#8004;
      ALARM_WRONG_DIRECTION : Word := 16#8007;
      ALARM_AXIS_DISABLED : Word := 16#800F;
   END_VAR


BEGIN
	//================================================================================
	//SIEMENS AG // (c)Copyright 2019 All Rights Reserved
	//--------------------------------------------------------------------------------
	//Library: LSimaHydTO
	//Tested with: S7-15xx
	//Engineering: TIA Portal  V15 (SW 2.5)
	//Restrictions: -
	//Requirements: S7-1500
	//Functionality:    controls the output of an axis directly according configuration
	//
	//--------------------------------------------------------------------------------
	//Change log table:
	//
	//Version     Date          Expert in charge    Changes applied
	//01.00.10    17.03.2018    APC_ERLF            First released version
	//================================================================================
	//
	REGION TRIGGERING
	  IF (#JogForward AND NOT #statJigFwdOld)
	    OR (#JogBackward AND NOT #statJogBkwdOld)
	  THEN
	    #CommandAborted := FALSE;
	    #statBusy := FALSE;
	    IF (#JogForward AND #Axis.Internal.Control.DirectOutput.commandValueForward <= 0.0) OR
	      (#JogBackward AND #Axis.Internal.Control.DirectOutput.commandValueBackward <= 0.0)
	    THEN
	      #Error := TRUE;
	      #ErrorID := #ALARM_WRONG_VALUE_VELOCITY;
	      #statFBState := #FB_STATE_ERROR;
	    ELSIF #Axis.Internal.Control.DirectOutput.commandValueRamp <= 0.0 THEN
	      #Error := TRUE;
	      #ErrorID := #ALARM_WRONG_VALUE_ACCEL;
	      #statFBState := #FB_STATE_ERROR;
	    ELSIF #JogForward AND #JogBackward THEN
	      #Error := TRUE;
	      #ErrorID := #ALARM_WRONG_DIRECTION;
	      #statFBState := #FB_STATE_ERROR;
	    ELSIF NOT #Axis.StatusActor.Enabled THEN
	      #Error := TRUE;
	      #ErrorID := #ALARM_AXIS_DISABLED;
	      #statFBState := #FB_STATE_ERROR;
	    ELSIF #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	      #Error := TRUE;
	      #ErrorID := #ALARM_AXIS_ERROR_OCCURED;
	      #statFBState := #FB_STATE_ERROR;
	    ELSE
	      #Axis.Internal.Control.DirectOutput.activate := TRUE;
	      #Axis.Internal.Control.DirectOutput.commandValueForward := #CommandValueForward;
	      #Axis.Internal.Control.DirectOutput.commandValueBackward := #CommandValueBackward;
	      #Axis.Internal.Control.DirectOutput.commandValueRamp := #CommandValueRamp;
	      #Axis.Internal.Control.DirectOutput.safetyDistance := #SafetyDistance;
	      #Axis.Internal.Control.DirectOutput.jogForward := #JogForward;
	      #Axis.Internal.Control.DirectOutput.jogBackward := #JogBackward;
	      
	      #statBusy := TRUE;
	      #Error := FALSE;
	      #ErrorID := #NO_ALARM;
	      #statFBState := #FB_STATE_JOG;
	    END_IF;
	    
	    
	  END_IF;
	  // Edge detection
	  #statJigFwdOld := #JogForward;
	  #statJogBkwdOld := #JogBackward;
	END_REGION
	
	IF #statFBState = #FB_STATE_IDLE THEN
	  RETURN;
	END_IF;
	
	REGION PRCESSING
	  IF #statBusy THEN
	    CASE #statFBState OF
	      #FB_STATE_JOG:
	        
	        IF NOT #Axis.StatusActor.Enabled OR #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	          #statBusy := FALSE;
	          #Error := TRUE;
	          IF #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	            #ErrorID := #ALARM_AXIS_ERROR_OCCURED;
	          ELSE
	            #ErrorID := #ALARM_AXIS_DISABLED;
	          END_IF;
	          #statFBState := #FB_STATE_ERROR;
	        ELSIF #Axis.Internal.MotionData.DirectOutput.rampingDown THEN
	          #Axis.Internal.Control.DirectOutput.jogForward := FALSE;
	          #Axis.Internal.Control.DirectOutput.jogBackward := FALSE;
	          
	          #statBusy := FALSE;
	          #CommandAborted := TRUE;
	          #statFBState := #FB_STATE_STOPPING;
	        ELSE
	          #Axis.Internal.Control.DirectOutput.jogForward := #JogForward;
	          #Axis.Internal.Control.DirectOutput.jogBackward := #JogBackward;
	          
	          IF NOT (#JogForward OR #JogBackward) THEN
	            
	            #statFBState := #FB_STATE_STOPPING;
	          END_IF;
	        END_IF;
	      #FB_STATE_STOPPING:
	        IF NOT #Axis.Internal.MotionData.DirectOutput.active THEN
	          #Axis.Internal.Control.DirectOutput.activate := FALSE;
	          #statBusy := FALSE;
	          #statFBState := #FB_STATE_IDLE;
	        END_IF;
	    END_CASE;
	  END_IF;
	END_REGION
	REGION OUTPUTS
	  
	  CASE #statFBState OF
	      
	    #FB_STATE_COMMAND_ABORTED:
	      IF NOT (#JogForward OR #JogBackward) THEN
	        #statBusy := FALSE;
	        #CommandAborted := FALSE;
	        
	        #statFBState := #FB_STATE_IDLE;
	      END_IF;
	      
	      
	    #FB_STATE_ERROR:
	      IF NOT (#JogForward OR #JogBackward) THEN
	        #statFBState := #FB_STATE_IDLE;
	        #Error := FALSE;
	        #ErrorID := #NO_ALARM;
	      END_IF;
	  END_CASE;
	  #RampingDown := #Axis.Internal.MotionData.DirectOutput.rampingDown;
	  #MinSafetyPositionOverrun := #Axis.Internal.MotionData.DirectOutput.minSafetyPositionOverrun;
	  #MaxSafetyPositionOverrun := #Axis.Internal.MotionData.DirectOutput.maxSafetyPositionOverrun;
	  #Busy := #statBusy;
	  IF #statFBState = #FB_STATE_IDLE THEN
	    #Axis.Internal.Control.DirectOutput.jogForward := FALSE;
	    #Axis.Internal.Control.DirectOutput.jogBackward := FALSE;
	    #Axis.Internal.Control.DirectOutput.activate := FALSE;
	    #statBusy := #Busy := #CommandAborted := #Error := #RampingDown := #MinSafetyPositionOverrun := #MaxSafetyPositionOverrun := FALSE;
	    #ErrorID := #NO_ALARM;
	  END_IF;
	END_REGION
END_FUNCTION_BLOCK


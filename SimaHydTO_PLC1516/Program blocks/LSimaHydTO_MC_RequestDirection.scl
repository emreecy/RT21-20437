FUNCTION_BLOCK "LSimaHydTO_MC_RequestDirection"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : APC_ERLF
FAMILY : LSimaHydTO
VERSION : 1.0
   VAR_INPUT 
      RequestForward : Bool;
      RequestBackward : Bool;
   END_VAR

   VAR_OUTPUT 
      ValveForward { ExternalWritable := 'False'} : Bool := FALSE;
      ValveBackward { ExternalWritable := 'False'} : Bool := FALSE;
      RampingForward { ExternalWritable := 'False'} : Bool;
      RampingBackward { ExternalWritable := 'False'} : Bool;
      Busy { ExternalWritable := 'False'} : Bool;
      CommandAborted { ExternalWritable := 'False'} : Bool;
      Error { ExternalWritable := 'False'} : Bool;
      ErrorID { ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_IN_OUT 
      Axis : "LSimaHydTO_typeAxisData";
   END_VAR

   VAR 
      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : SInt;
      statReqFwdOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statReqBackOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;
   END_VAR

   VAR CONSTANT 
      STATE_IDLE : SInt;
      STATE_MOVEMENT : SInt := 10;
      STATE_STOPPING : SInt := 20;
      STATE_COMMAND_ABORTED : SInt := 30;
      STATE_ERROR : SInt := -100;
      NO_ERROR_REACTION : DInt := 0;
      NO_ALARM : Word := 0;
      ALARM_AXIS_ERROR_OCCURED : Word := 16#8001;
      ALARM_WRONG_DIRECTION : Word := 16#8007;
      ALARM_AXIS_DISABLED : Word := 16#800F;
   END_VAR


BEGIN
	//================================================================================
	//SIEMENS AG // (c)Copyright 2019 All Rights Reserved
	//--------------------------------------------------------------------------------
	//Library: LSimaHydTO
	//Tested with: S7-15xx
	//Engineering: TIA Portal  V15 (SW 2.5)
	//Restrictions: -
	//Requirements: S7-1500
	//Functionality:    request switching direction valves and recognize the enabling of motion control
	//
	//--------------------------------------------------------------------------------
	//Change log table:
	//
	//Version     Date          Expert in charge    Changes applied
	//01.00.00    11.09.2019    APC_ERLF            First released version
	//================================================================================
	
	#tempExecute := (#RequestForward AND NOT #statReqFwdOld)
	             OR (#RequestBackward AND NOT #statReqBackOld);
	             
	//
	IF #tempExecute AND NOT #statExecuteOld THEN
	  #CommandAborted := FALSE;
	  #Busy := FALSE;
	  IF #RequestForward AND #RequestBackward THEN
	    #Error := TRUE;
	    #ErrorID := #ALARM_WRONG_DIRECTION;
	    #statFBState := #STATE_ERROR;
	  ELSIF NOT #Axis.StatusActor.Enabled THEN
	    #Error := TRUE;
	    #ErrorID := #ALARM_AXIS_DISABLED;
	    #statFBState := #STATE_ERROR;
	  ELSIF #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	    #Error := TRUE;
	    #ErrorID := #ALARM_AXIS_ERROR_OCCURED;
	    #statFBState := #STATE_ERROR;
	  ELSE
	    #Axis.Internal.Control.RequestForward := #RequestForward;
	    #Axis.Internal.Control.RequestBackward := #RequestBackward;
	    
	    #Busy := TRUE;
	    #Error := FALSE;
	    #ErrorID := #NO_ALARM;
	    #statFBState := #STATE_MOVEMENT;
	  END_IF;
	END_IF;
	 
	
	#statReqFwdOld := #RequestForward;
	#statReqBackOld := #RequestBackward;
	#statExecuteOld := #tempExecute;
	             
	             
	
	  CASE #statFBState OF
	    #STATE_IDLE:  // Idle
	      ;
	      
	    #STATE_MOVEMENT:
	      
	      IF NOT #Axis.StatusActor.Enabled OR #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	        #Busy := FALSE;
	        #Error := TRUE;
	        IF #Axis.ErrorDetail.Reaction <> #NO_ERROR_REACTION THEN
	          #ErrorID := #ALARM_AXIS_ERROR_OCCURED;
	        ELSE
	          #ErrorID := #ALARM_AXIS_DISABLED;
	        END_IF;
	        #statFBState := #STATE_ERROR;
	      ELSIF NOT (#RequestForward OR #RequestBackward) THEN
	          #Axis.Internal.Control.RequestForward := FALSE;
	          #Axis.Internal.Control.RequestBackward := FALSE;
	          
	          #statFBState := #STATE_IDLE;
	          
	        
	      ELSIF     #Axis.Internal.Control.RequestForward <> #RequestForward
	        OR  #Axis.Internal.Control.RequestBackward <> #RequestBackward
	      THEN
	        
	        #Busy := FALSE;
	        #CommandAborted := TRUE;
	        #statFBState := #STATE_COMMAND_ABORTED;
	      END_IF;
	  END_CASE;
	  
	  CASE #statFBState OF
	      
	    #STATE_COMMAND_ABORTED:
	      IF NOT (#RequestForward OR #RequestBackward) THEN
	        #CommandAborted := FALSE;
	        
	        #statFBState := #STATE_IDLE;
	      END_IF;
	      
	    #STATE_ERROR:
	      IF NOT (#RequestForward OR #RequestBackward) THEN
	        #statFBState := #STATE_IDLE;
	        #Error := FALSE;
	        #ErrorID := #NO_ALARM;
	      END_IF;
	  END_CASE;
	  
	  // write outputs
	  #ValveForward := #Axis.StatusActor.ValveForward;
	  #ValveBackward := #Axis.StatusActor.ValveBackward;
	  #RampingForward := #Axis.Internal.MotionData.RampingForward;
	  #RampingBackward := #Axis.Internal.MotionData.RampingBackward;
	  
END_FUNCTION_BLOCK


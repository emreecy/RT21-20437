FUNCTION "LSimaHydTO_CreateVChar" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : APC_ERLF
FAMILY : LSimaHydTO
VERSION : 1.0
   VAR_IN_OUT 
      measuredValues : "LSimaHydTO_typeMeasuredValues";
      vchar : "LSimaHydTO_typeVCharData";
   END_VAR

   VAR_TEMP 
      tempIdx : Int;
      tmpNumOfPoints : Int;
   END_VAR


BEGIN
	//================================================================================
	//SIEMENS AG // (c)Copyright 2019 All Rights Reserved
	//--------------------------------------------------------------------------------
	//Library:       LSimaHydTO
	//Tested with:   S7-15xx
	//Engineering:   TIA Portal  V15
	//Restrictions:  -
	//Requirements:  S7-1500 (FW 2.5)
	//Functionality: Create valve characteristic from measured data
	//
	//--------------------------------------------------------------------------------
	//Change log table:
	//
	//Version     Date          Expert in charge    Changes applied
	//01.00.00    15.03.2018    APC_ERLF            First released version
	//================================================================================
	
	
	#tmpNumOfPoints := #measuredValues.forward.maxIndexMeasurement + #measuredValues.backward.maxIndexMeasurement + 1;
	IF ABS(#measuredValues.backward.minQOutput) > 0.0 THEN
	  #tmpNumOfPoints := #tmpNumOfPoints + 1;
	END_IF;
	IF #tmpNumOfPoints  > "LSIMAHYD_VCHAR_POINTS_UPPER_LIMIT" + 1 THEN
	  #LSimaHydTO_CreateVChar := -1;
	  RETURN;
	END_IF;
	
	//reset VChar
	#vchar.VelocityLimitPositive := #measuredValues.forward.maxVelocity;
	#vchar.ZeroZonePositive := #measuredValues.forward.minQOutput;
	#vchar.VelocityLimitNegative := #measuredValues.backward.maxVelocity;
	#vchar.ZeroZoneNegative := #measuredValues.backward.minQOutput;
	#vchar.MaxIdx := 0;
	FOR #tempIdx := 0 TO "LSIMAHYD_VCHAR_POINTS_UPPER_LIMIT" DO
	  #vchar.QOutput[#tempIdx] := 0.0;
	  #vchar.Velocity[#tempIdx] := 0.0;
	END_FOR;
	IF #measuredValues.backward.maxIndexMeasurement > 0 THEN
	  FOR #tempIdx := #measuredValues.backward.maxIndexMeasurement TO 1 BY -1 DO
	      #vchar.Velocity[#vchar.MaxIdx] := #measuredValues.backward.velocity[#tempIdx];
	      #vchar.QOutput[#vchar.MaxIdx] := #measuredValues.backward.qOutput[#tempIdx];
	      #vchar.MaxIdx := #vchar.MaxIdx + 1;
	  END_FOR;
	END_IF;
	IF ABS(#vchar.ZeroZoneNegative) > 0.0 THEN
	  #vchar.Velocity[#vchar.MaxIdx] := #measuredValues.backward.velocity[0];
	  #vchar.QOutput[#vchar.MaxIdx] := #measuredValues.backward.qOutput[0];
	  #vchar.MaxIdx := #vchar.MaxIdx + 1;
	END_IF;
	IF #measuredValues.forward.maxIndexMeasurement > 0 THEN
	  FOR #tempIdx := 0 TO #measuredValues.forward.maxIndexMeasurement DO
	    #vchar.Velocity[#vchar.MaxIdx] := #measuredValues.forward.velocity[#tempIdx];
	      #vchar.QOutput[#vchar.MaxIdx] := #measuredValues.forward.qOutput[#tempIdx];
	      #vchar.MaxIdx := #vchar.MaxIdx + 1;
	  END_FOR;
	ELSIF #vchar.ZeroZoneNegative = 0.0 THEN
	  #vchar.Velocity[#vchar.MaxIdx] := #measuredValues.backward.velocity[0];
	  #vchar.QOutput[#vchar.MaxIdx] := #measuredValues.backward.qOutput[0];
	  #vchar.MaxIdx := #vchar.MaxIdx + 1;
	END_IF;
	#vchar.MaxIdx := #vchar.MaxIdx - 1;
	#LSimaHydTO_CreateVChar := 0;
	
	
END_FUNCTION


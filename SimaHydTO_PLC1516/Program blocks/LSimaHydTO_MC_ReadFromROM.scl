FUNCTION_BLOCK "LSimaHydTO_MC_ReadFromROM"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : APC_ERLF
FAMILY : LSimaHydTO
VERSION : 1.0
   VAR_INPUT 
      execute : Bool;
      parameter : Int;
   END_VAR

   VAR_OUTPUT 
      busy { ExternalWritable := 'False'} : Bool;
      done { ExternalWritable := 'False'} : Bool;
      commandAborted { ExternalWritable := 'False'} : Bool;
      error { ExternalWritable := 'False'} : Bool;
      errorID { ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_IN_OUT 
      axis : "LSimaHydTO_typeAxisData";
   END_VAR

   VAR 
      statState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt;
      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statBusyRead { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statRetVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Int;
   END_VAR

   VAR_TEMP 
      tempVarParameter : Variant;
   END_VAR

   VAR CONSTANT 
      STATE_IDLE : DInt := 0;
      LAST_PARAM : DInt := 10;
   END_VAR


BEGIN
	//================================================================================
	//SIEMENS AG // (c)Copyright 2019 All Rights Reserved
	//--------------------------------------------------------------------------------
	//Library:       LSimaHydTO
	//Tested with:   S7-15xx
	//Engineering:   TIA Portal  V15
	//Restrictions:  -
	//Requirements:  S7-1500 (FW 2.5)
	//Functionality: Read parameter from ROM into RAM 
	//
	//--------------------------------------------------------------------------------
	//Change log table:
	//
	//Version     Date          Expert in charge    Changes applied
	//01.00.00    15.03.2018    APC_ERLF            First released version
	//================================================================================
	
	
	IF #execute AND NOT #statExecuteOld THEN
	  #done := FALSE;
	  #busy := TRUE;
	  #statBusyRead := TRUE;
	  #error := FALSE;
	  #errorID := 0;
	  IF #parameter = 0 OR #parameter = 1 THEN
	    #statState := 1;
	  ELSE
	    #statState := #parameter;
	  END_IF;
	END_IF;
	IF #statBusyRead THEN
	  
	  CASE #statState OF
	      
	    1: // actor
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.Actor, BUSY => #statBusyRead, DSTBLK => #axis.Actor);
	      
	      
	    2: // valve characteristic
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.ValveCharacteristic, BUSY => #statBusyRead, DSTBLK => #axis.ValveCharacteristic);
	      
	      
	    3: // force limits
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.ForceLimits, BUSY => #statBusyRead, DSTBLK => #axis.ForceLimits);
	      
	      
	    4: // ring transducer
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.Pressure_A_Transducer, BUSY => #statBusyRead, DSTBLK => #axis.Pressure_A_Transducer);
	      
	      
	    5: // piston transducer
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.Pressure_B_Transducer, BUSY => #statBusyRead, DSTBLK => #axis.Pressure_B_Transducer);
	      
	      
	    6: // position control
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.PositionControl, BUSY => #statBusyRead, DSTBLK => #axis.PositionControl);
	      
	      
	    7: // force control
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.ForceControl, BUSY => #statBusyRead, DSTBLK => #axis.ForceControl);
	      
	      
	    8: // dynamic axis model
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.DynamicAxisModel, BUSY => #statBusyRead, DSTBLK => #axis.DynamicAxisModel);
	      
	      
	    9: // smoothing filter
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.SmoothingFilter, BUSY => #statBusyRead, DSTBLK => #axis.SmoothingFilter);
	      
	      
	    10: // name
	      
	      #statRetVal := READ_DBL(REQ := TRUE, SRCBLK := #axis.Name, BUSY => #statBusyRead, DSTBLK => #axis.Name);
	      
	      
	    ELSE
	      #statState := #STATE_IDLE;
	      #statBusyRead := FALSE;
	  END_CASE;
	  
	  IF NOT #statBusyRead THEN
	    IF #statRetVal = 0 THEN
	      IF #parameter = 0 AND #statState < #LAST_PARAM THEN
	        #statState := 1 + #statState;
	        #statBusyRead := TRUE;
	      ELSE
	        #busy := false;
	        #done := TRUE;
	      END_IF;
	    ELSE
	      #busy := FALSE;
	      #error := TRUE;
	      #errorID := INT_TO_WORD(#statRetVal);
	      #statState := #STATE_IDLE;
	    END_IF;
	  END_IF;
	ELSIF NOT #execute THEN
	  #done := FALSE;
	  #error := FALSE;
	  #errorID := 0;
	END_IF;
	#statExecuteOld := #execute;
	
END_FUNCTION_BLOCK

